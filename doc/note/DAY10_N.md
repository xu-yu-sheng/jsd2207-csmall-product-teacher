# DAY10晚课：密码加密

关于消息摘要算法的破解：所有消息摘要算法都是不可逆向运算的，尝试将消息摘要运算结果运算还原出原本数据的思路本身就是错误的！一个成熟可靠的消息摘要算法，理论上，极难找出2个不同的原始数据对应相同的摘要，如果出现了这样的情况，称之“碰撞”，关于消息摘要算法的破解，本身是研究碰撞，与逆向运算无关！

如果需要根据使用消息算法编码得到的密文还原出密码的原文，常见做法是使用穷举法，记录各原文与密文的对应关系，当需要“破解”时，本质上是在执行查询操作！

| 原文（消息） | 密文（摘要）                       |
| ------------ | ---------------------------------- |
| `000000`     | `670b14728ad9902aecba32e22fa4f6bd` |
| `111111`     | `96e79218965eb72c92a549dd5a330112` |
| `222222`     | `e3ceb5881a0a1fdaad01296d7554868d` |
| `333333`     | `1a100d2c0dab19c4430e7d73762b3423` |
| `444444`     | `73882ab1fa529d7273da0db6b49cc4f3` |
| `555555`     | `5b1b68a9abf4d2cd155c81a9225fd158` |

其实，这样的做法能够“破解”的密码是**非常有限**的！假设密码可以使用所有的可打印字符（共计95种），如果密码的长度只有1位，则可以有95种不同的密码，如果密码的长度有2位，则可以有95 x 95种不同的密码，以此类推，如果密码的长度有6位，则可以有735,091,890,625种（7350亿种）不同的密码，如果密码的长度有8位，则可以有6,634,204,312,890,625种（约6634万亿种）不同的密码，所以，如果需要反查出任何8位长度的密码，则需要记录下6600多万亿条数据才可以！

所以，最有效的保证密码安全的做法是要求用户使用**安全强度更高的密码**，例如密码至少有8位，且密码中必须同时包含字母、数字、标点符号等。

为了进一步提高密码的安全性，在编码过程中，还应该使用“盐值”，盐值是一个自定义的字符串，它应该与原密码一并作为消息摘要算法的被运算数据，则对于算法而言，被运算数据就不再只是简单的密码原文而已，则密码原文与盐值组合的结果，例如：

```java
String salt = "75ifDV8rqHLfrFw87TFylDGSLGah";
String rawPassword = "000000";
String encodedPassword = DigestUtils
            .md5DigestAsHex((salt + rawPassword + salt).getBytes());
System.out.println("原文：" + rawPassword);
System.out.println("密文：" + encodedPassword);
```

不过，尽管加盐可以非常有效的防止密码被反查，但是，如果算法、运算参数（例如盐值等）、密文同时被泄露，依然可能会被**穷举式的暴力破解**。

目前，更推荐使用BCrypt算法对密码加密进行处理，这种算法默认就使用了随机的盐，并且，将盐值作为加密结果的一部分，以此保证密文是可以被验证的！更重要的是，BCrypt算法被设计为**非常非常慢**的算法，

总的来说，要最大限度的保证密码安全，应该：

- 要求用户使用安全强度更高的密码
- 加盐
- 多重加密
- 使用安全系数更强的算法
- 综合以上做法

